#version 450
layout (local_size_x = 1024) in;
precision highp float;

#define PI 3.1415926538

struct Particle {
    vec3 x;                     // position
    float h;                    // radius
    vec3 v;                     // velocity
    float m;                    // mass

    float rho;                  // density
    float p;                    // pressure

    //float padding1;
    //float padding2;
};

layout(set = 0, binding = 0) uniform SimulationProperties {
    float desired_density;
    float k;                    // normalization constant / stiffness constant
    float nr_of_particles;
    float kernelh;
} SimProps;

layout(set = 0, binding = 1, std430) buffer inBuffer {
    Particle p[];
} storage_out;

layout(set = 0, binding = 2, std430) buffer outBuffer {
    Particle p[];
} storage_in;

// Kernel function from https://interactivecomputergraphics.github.io/SPH-Tutorial/pdf/SPH_Tutorial.pdf
// http://web.cse.ohio-state.edu/~wang.3602/courses/cse3541-2017-fall/08-SPH.pdf
float kernel(Particle i, Particle j, float h) {
    float q = length(i.x - j.x)/h;
    float ret = 0;

    if (0 <= q && q < 1) {
        //ret = 6 * (pow(q, 3.0) - pow(q, 2.0)) + 1;
        ret = 2.0/3.0 - pow(q, 2.0) + pow(q, 3.0)/2.0;
    } else if (1 <= q && q < 2) {
        //ret = 2 * pow(1 - q, 3.0);
        ret =  pow(2 - q, 3.0)/6.0;
    } else {
        ret = 0;
    }

    //ret *= 8.0/(PI * pow(h, 3.0));
    ret *= 3.0/(2.0 * PI * pow(h, 3.0));
    return ret;
}

/**
* http://web.cse.ohio-state.edu/~wang.3602/courses/cse3541-2017-fall/08-SPH.pdf
* 12. dia
*/
vec3 gradKernel(Particle pi, Particle pj) {
    vec3 xij = normalize(pi.x - pj.x);
    //xij /= SimProps.kernelh;
    xij /= 0.1;

    float val = 0;
    //float q = length(pi.x - pj.x)/SimProps.kernelh;
    float q = length(pi.x - pj.x)/0.1;
    if (0 <= q && q < 1) {
        //val = 18 * pow(q, 2.0) - 12 * q;
        val = -2 * q + 3.0/2.0 * pow(q, 2.0);
    } else if (1 <= q && q < 2) {
        //val = -6 * pow(1 - q, 2.0);
        val = -1.0/2.0 * pow(2 - q, 2.0);
    } else {
        val = 0;
    }
    //val *= 8.0/(PI * pow(h, 3.0));
    //val *= 3.0/(2.0 * PI * pow(SimProps.kernelh, 3.0));
    val *= 3.0/(2.0 * PI * pow(0.1, 3.0));
    xij *= val;

    return xij;
}

vec3 calculatePressureF(uint gID) {
    Particle pi = storage_in.p[gID];

    vec3 gradPi;
    //for (int j = 0; j < SimProps.nr_of_particles; j++) {
    for (int j = 0; j < 64; j++) {
        if (j == gID)
            continue;

        Particle pj = storage_in.p[j];
        //float val = pj.m * ((pi.p / pow(pi.rho, 2)) + (pj.p / pow(pj.rho, 2)));
        float val = 1.0;
        gradPi += val * gradKernel(pi, pj);
    }

    //gradPi *= pi.rho;
    gradPi *= -pi.m;

    return gradPi;
}

vec3 calculateViscosityF(uint gID) {
    Particle pi = storage_in.p[gID];

    vec3 ret = vec3(0);
    for (int j = 0; j < SimProps.nr_of_particles; j++) {
        if (j == gID)
            continue;

        Particle pj = storage_in.p[j];
        vec3 xij = pi.x - pj.x;
        //float val = (pj.m / pj.rho) * (dot(xij, gradKernel(pi, pj)) /  (dot(xij, xij) + 0.01 /* times h^2*/));
        float val = (dot(xij, gradKernel(pi, pj)) /  (dot(xij, xij) + 0.01 /* times h^2*/));
        vec3 vij = pi.v - pj.v;
        ret += val * vij;
    }

    float nu = 0.00001;

    ret *= 2 * nu * pi.m;
    return ret;
}

vec3 calcAcc(uint gID) {
    Particle pi = storage_in.p[gID];
    vec3 Fpressure = calculatePressureF(gID);
    vec3 Fviscosity = calculateViscosityF(gID);
    vec3 Fother = pi.m * vec3(0, 0, -9.8);
    Fother = vec3(0);
    vec3 F = Fpressure + Fviscosity + Fother;
    vec3 acc = F / pi.m;
    //vec3 acc = F / 1.0;

    return acc;
}

void main() {
    uint gID = gl_GlobalInvocationID.x;
    Particle pi = storage_in.p[gID];

    //vec3 vi = pi.v +
    //Euler integration:
    vec3 viNext = pi.v;
    vec3 xiNext = pi.x;

    vec3 acc = calcAcc(gID);

    float dt = 0.01;
    viNext += acc * dt/2;
    xiNext += viNext * dt;
    acc = calcAcc(gID);
    viNext += acc * dt/2;

    /*storage_out.p[gID].x = xiNext;
    storage_out.p[gID].h = pi.h;
    storage_out.p[gID].v = viNext;
    storage_out.p[gID].m = pi.m;

    storage_out.p[gID].rho = pi.rho;
    storage_out.p[gID].p = pi.p;*/

    //storage_out.p[gID].padding1 = 0;
    //storage_out.p[gID].padding2 = 0;

    storage_out.p[gID].x = storage_in.p[gID].x*1.001;
    storage_out.p[gID].h = storage_in.p[gID].h;
    storage_out.p[gID].v = storage_in.p[gID].v;
    storage_out.p[gID].m = storage_in.p[gID].m;

    storage_out.p[gID].rho = storage_in.p[gID].rho;
    storage_out.p[gID].p = storage_in.p[gID].p;

    //storage_out.p[gID].padding1 = length(acc);
    //storage_out.p[gID].padding2 = length(acc);

    //storage_out.p[gID].padding1 = 1/0;
}