#version 450
layout (local_size_x = 1024) in;
precision highp float;

#define PI 3.1415926538

struct Particle {
    vec3 x;                     // position
    float h;                    // radius
    vec3 v;                     // velocity
    float m;                    // mass

    float rho;                  // density
    float p;                    // pressure
};

layout(set = 0, binding = 0) uniform SimulationProperties {
    float desired_density;
    float k;                    // normalization constant / stiffness constant
    float nr_of_particles;
    float kernelh;
} SimProps;

layout(set = 0, binding = 1, std430) buffer inBuffer {
    Particle p[];
} storage_out;

layout(set = 0, binding = 2, std430) buffer outBuffer {
    Particle p[];
} storage_in;

/**
* http://web.cse.ohio-state.edu/~wang.3602/courses/cse3541-2017-fall/08-SPH.pdf
* 12. dia
*/
vec3 gradKernel(Particle pi, Particle pj) {
    vec3 xij = normalize(pi.x - pj.x);
    //xij /= SimProps.kernelh;
    //xij /= 0.1;

    float val = 0;
    float q = length(pi.x - pj.x)/SimProps.kernelh;
    //float q = length(pi.x - pj.x)/0.1;
    if (0 <= q && q < 1) {
        //val = 18 * pow(q, 2.0) - 12 * q;
        //val = -2 * q + 3.0/2.0 * pow(q, 2.0);

        val = 3/2 * pow(q,2) - 2 * q;
    } else if (1 <= q && q < 2) {
        //val = -6 * pow(1 - q, 2.0);
        //val = -1.0/2.0 * pow(2 - q, 2.0);

        val = -pow(2 - q, 2)/2.0;
    } else {
        val = 0;
    }
    //val *= 8.0/(PI * pow(h, 3.0));
    //val *= 3.0/(2.0 * PI * pow(SimProps.kernelh, 3.0));
    //val *= 3.0/(2.0 * PI * pow(0.1, 3.0));

    val *= 3/(2*PI) * 1/(pow(SimProps.kernelh, 3));
    xij *= val;

    return xij;
}

vec3 calculatePressureF(uint gID) {
    Particle pi = storage_in.p[gID];

    vec3 gradPi = vec3(0);
    for (int j = 0; j < SimProps.nr_of_particles; j++) {
        if (j == gID)
            continue;

        Particle pj = storage_in.p[j];
        float val = pj.m * ((pi.p / pow(pi.rho, 2)) + (pj.p / pow(pj.rho, 2)));
        gradPi += val * gradKernel(pi, pj);
    }

    //gradPi *= pi.rho;
    //gradPi /= pi.rho;
    gradPi *= -pi.m;

    return gradPi;
}
// https://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf
vec3 calculateViscosityF(uint gID) {
    Particle pi = storage_in.p[gID];

    vec3 ret = vec3(0);
    for (int j = 0; j < SimProps.nr_of_particles; j++) {
        if (j == gID)
            continue;

        Particle pj = storage_in.p[j];
        vec3 xij = pi.x - pj.x;
        float val = (pj.m / pj.rho) * (dot(xij, gradKernel(pi, pj)) /  (dot(xij, xij) + 0.01 * SimProps.kernelh));
        //float val = (dot(xij, gradKernel(pi, pj)) /  (dot(xij, xij) + 0.01 /*times h^2*/));
        vec3 vij = pi.v - pj.v;
        ret += val * vij;
    }

    float nu = 0.00001;

    ret *= 2 * nu * pi.m;
    return ret;
}

vec3 calcAcc(uint gID) {
    Particle pi = storage_in.p[gID];

    vec3 Fpressure = calculatePressureF(gID);
    vec3 Fviscosity = calculateViscosityF(gID);
    vec3 Fother = pi.m * vec3(0, 0, -9.8);
    Fother = vec3(0);
    vec3 F = Fpressure + Fviscosity + Fother;
    vec3 acc = F / pi.m;
    //vec3 acc = F / 1.0;

    return acc;

    /*vec3 acc = vec3(0,0,0);
    for (int j = 0; j < SimProps.nr_of_particles; j++) {
        if (j == gID)
            continue;

        Particle pj = storage_in.p[j];

        vec3 grad = gradKernel(pi, pj);
        acc += pj.m * (pi.p / pow(pi.rho, 2.0) + pj.p / pow(pj.rho, 2.0)) * grad;
    }

    acc -= 1 * pi.v;
    return -1 * acc;*/
}

void main() {
    uint gID = gl_GlobalInvocationID.x;
    Particle pi = storage_in.p[gID];

    vec3 viNext = pi.v;
    vec3 xiNext = pi.x;

    vec3 acc = calcAcc(gID);

    //float dt = 0.01;
    float dt = 0.00000001;
    viNext += acc * dt/2;
    xiNext += viNext * dt;

    storage_out.p[gID].x = xiNext;
    storage_out.p[gID].h = pi.h;
    storage_out.p[gID].v = viNext;
    storage_out.p[gID].m = pi.m;

    storage_out.p[gID].rho = pi.rho;
    storage_out.p[gID].p = pi.p;

    //storage_out.p[gID].padding1 = 0;
    //storage_out.p[gID].padding2 = 0;

    /*storage_out.p[gID].x = storage_in.p[gID].x*1.001;
    storage_out.p[gID].h = storage_in.p[gID].h;
    storage_out.p[gID].v = viNext;
    storage_out.p[gID].m = storage_in.p[gID].m;

    storage_out.p[gID].rho = storage_in.p[gID].rho;
    storage_out.p[gID].p = storage_in.p[gID].p;*/
}