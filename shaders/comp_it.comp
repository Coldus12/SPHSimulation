#version 450
layout (local_size_x = 256) in;
precision highp float;

#define PI 3.1415926538

#define list_size 12

struct Particle {
    vec3 x;                     // position
    float h;                    // radius
    vec3 v;                     // velocity
    float m;                    // mass

    float rho;                  // density
    float p;                    // pressure

    float staticP;
    float padding;
};

layout(set = 0, binding = 0) uniform SimulationProperties {
    float desired_density;
    float k;                    // normalization constant / stiffness constant
    float nr_of_particles;
    float kernelh;

    vec4 gridA;
    vec4 gridB;
} SimProps;

layout(set = 0, binding = 1, std430) buffer inBuffer {
    Particle p[];
} storage_out;

layout(set = 0, binding = 2, std430) buffer outBuffer {
    Particle p[];
} storage_in;

layout(set = 0, binding = 3, std430) buffer gridBuffer {
    int numbers[];
} grid_data;

//----------------------------------------------------------------------------------------------------------------------
struct Neighbourhood {
    vec3 neighbour[27]; // 3^3
};

int cellx = int(ceil(abs((SimProps.gridB.x - SimProps.gridA.x)/SimProps.kernelh))); // Number of cells in x direction
int celly = int(ceil(abs((SimProps.gridB.y - SimProps.gridA.y)/SimProps.kernelh))); // Number of cells in y direction
int cellz = int(ceil(abs((SimProps.gridB.z - SimProps.gridA.z)/SimProps.kernelh))); // Number of cells in z direction

vec3 determineGridTuple(int particleIdx) {
    vec3 diff = SimProps.gridA.xyz - storage_in.p[particleIdx].x;
    diff /= SimProps.kernelh;

    return floor(abs(diff));
}

int getStartIdxOfCell(vec3 tuple) {
    return int((tuple.x * cellz * celly + tuple.y * cellz + tuple.z)*list_size);
}

Neighbourhood getNeighbouringCells(vec3 cellTuple) {
    Neighbourhood ret;

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < 3; k++) {
                ret.neighbour[i * 9 + j * 3 + k] = vec3(cellTuple.x + (i-1), cellTuple.y + (j-1), cellTuple.z + (k-1));
            }
        }
    }

    return ret;
}

bool checkBounds(vec3 tuple) {
    if (tuple.x < 0 || tuple.x >= cellx)
        return false;

    if (tuple.y < 0 || tuple.y >= celly)
        return false;

    if (tuple.z < 0 || tuple.z >= cellz)
        return false;

    return true;
}
//----------------------------------------------------------------------------------------------------------------------

// Constants
float m_k = 48.0 / (pow(SimProps.kernelh, 3) * PI);
float m_l = 1.0/(pow(SimProps.kernelh, 3)) * 3.0/(2.0*PI);

// Changed kernel to the CubicKernel by SPlisHSPHlasH:
// https://www.interactive-graphics.de/SPlisHSPlasH/doc/html/_s_p_h_kernels_8h_source.html
// (This is the one from the eurographics 2019 document, except now i finally understand their gradient notation)
vec3 gradKernel(vec3 i, vec3 j) {
    vec3 r = i - j;
    float rlength = length(r);
    float q = rlength / SimProps.kernelh;
    vec3 ret = vec3(0);

    if (q > 0.0001 && q <= 1.0) {
        vec3 gradq = r / (rlength * SimProps.kernelh);

        if (q <= 0.5) {
            ret = m_k * q * (3.0 * q - 2) * gradq;
        } else {
            float factor = 1.0 - q;
            ret = m_k * (-factor * factor) * gradq;
        }
    }

    return ret;
}

void copyData(uint gID) {
    storage_out.p[gID].x = storage_in.p[gID].x;
    storage_out.p[gID].h = storage_in.p[gID].h;
    storage_out.p[gID].v = storage_in.p[gID].v;
    storage_out.p[gID].m = storage_in.p[gID].m;

    storage_out.p[gID].rho = storage_in.p[gID].rho;
    storage_out.p[gID].p = storage_in.p[gID].p;

    storage_out.p[gID].staticP = storage_in.p[gID].staticP;
    storage_out.p[gID].padding = 1;
}

void iterate(uint gID) {
    vec3 pressure = vec3(0);
    vec3 viscosity = vec3(0);

    /*for (int j = 0; j < SimProps.nr_of_particles; j++) {
        if (gID == j)
            continue;

        // Note to self: as the particles get further and further from each other the density decreases which means rho --> 0
        // which leads to something/0^2, which is either inf or -inf ----> nan or -nan
        float val = 0;
        if (storage_in.p[j].rho != 0 && storage_in.p[gID].rho != 0)
            val = storage_in.p[j].m * ((storage_in.p[gID].p / pow(storage_in.p[gID].rho, 2)) + (storage_in.p[j].p / pow(storage_in.p[j].rho, 2)));

        vec3 k = gradKernel(storage_in.p[gID].x, storage_in.p[j].x);
        pressure += val * gradKernel(storage_in.p[gID].x, storage_in.p[j].x);

        vec3 xij = storage_in.p[gID].x - storage_in.p[j].x;

        float pval = 0;
        if (storage_in.p[j].rho != 0)
            pval = (storage_in.p[j].m / storage_in.p[j].rho) * (dot(xij, gradKernel(storage_in.p[gID].x, storage_in.p[j].x)) /  (dot(xij, xij) + 0.01 * SimProps.kernelh));

        vec3 vij = storage_in.p[gID].v - storage_in.p[j].v;
        viscosity += pval * vij;
    }*/

    vec3 tuple = determineGridTuple(int(gID));
    Neighbourhood n = getNeighbouringCells(tuple);
    for (int i = 0; i < 27; i++) {
        vec3 current = n.neighbour[i];
        if (!checkBounds(current)) continue;

        int size = grid_data.numbers[getStartIdxOfCell(current)];
        int iterIdx = 0;
        for (int j = 1; j < size; j++) {
            iterIdx = grid_data.numbers[j];
            if (gID == iterIdx) continue;

            // Note to self: as the particles get further and further from each other the density decreases which means rho --> 0
            // which leads to something/0^2, which is either inf or -inf ----> nan or -nan
            float val = 0;
            if (storage_in.p[iterIdx].rho != 0 && storage_in.p[gID].rho != 0)
            val = storage_in.p[iterIdx].m * ((storage_in.p[gID].p / pow(storage_in.p[gID].rho, 2)) + (storage_in.p[iterIdx].p / pow(storage_in.p[iterIdx].rho, 2)));

            vec3 k = gradKernel(storage_in.p[gID].x, storage_in.p[iterIdx].x);
            pressure += val * gradKernel(storage_in.p[gID].x, storage_in.p[iterIdx].x);

            vec3 xij = storage_in.p[gID].x - storage_in.p[iterIdx].x;

            float pval = 0;
            if (storage_in.p[iterIdx].rho != 0)
            pval = (storage_in.p[iterIdx].m / storage_in.p[iterIdx].rho) * (dot(xij, gradKernel(storage_in.p[gID].x, storage_in.p[iterIdx].x)) /  (dot(xij, xij) + 0.01 * SimProps.kernelh));

            vec3 vij = storage_in.p[gID].v - storage_in.p[iterIdx].v;
            viscosity += pval * vij;
        }
    }

    pressure *= -storage_in.p[gID].m;

    float nu = 0.01;
    viscosity *= 2 * nu * storage_in.p[gID].m;

    vec3 gravity = vec3(0, 0, -9.81) * storage_in.p[gID].m;
    
    vec3 acc = (pressure + viscosity + gravity) / storage_in.p[gID].m;

    float dt = 0.01;
    vec3 viNext = storage_in.p[gID].v;
    vec3 xiNext = storage_in.p[gID].x;
    viNext += acc * dt;

    float vil = length(viNext);
    xiNext += viNext * dt;
    
    storage_out.p[gID].x = xiNext;
    storage_out.p[gID].v = viNext;
    storage_out.p[gID].rho = storage_in.p[gID].rho;
    storage_out.p[gID].p = storage_in.p[gID].p;
}

void main() {
    uint gID = gl_GlobalInvocationID.x;

    if (gID < SimProps.nr_of_particles) {
        copyData(gID);
        if (storage_in.p[gID].staticP == 0)
            iterate(gID);
    }
}