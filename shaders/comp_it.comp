#version 450
layout (local_size_x = 1) in;
precision highp float;

#define PI 3.1415926538

struct Particle {
    vec3 x;                     // position
    float h;                    // radius
    vec3 v;                     // velocity
    float m;                    // mass

    float rho;                  // density
    float p;                    // pressure

    float staticP;
    float padding;
};

layout(set = 0, binding = 0) uniform SimulationProperties {
    float desired_density;
    float k;                    // normalization constant / stiffness constant
    float nr_of_particles;
    float kernelh;
} SimProps;

layout(set = 0, binding = 1, std430) buffer inBuffer {
    Particle p[];
} storage_out;

layout(set = 0, binding = 2, std430) buffer outBuffer {
    Particle p[];
} storage_in;

// SDF stuff
//----------------------------------------------------------------------------------------------------------------------

vec4 sphere = vec4(0,0,-0.2,1);
Particle phantomNeighbors[64];
int actualNr = 0;
int sampleSize = 4;

// Returns smallest distance to sphere s
float sphMap(vec3 p, vec4 s) {
    float d = distance(p, s.xyz) - s.w;
    return d;
}

vec3 getClosestPoint(vec3 particlePos) {
    float d = sphMap(particlePos, sphere);
    return (sphere.xyz - particlePos) * d;
}

void getNeighbours(Particle p) {
    vec3 closestP = getClosestPoint(p.x);
    float dist = 0.1;
    vec3 start = closestP - vec3(-sampleSize*dist,-sampleSize*dist, -sampleSize*dist);

    for (int i = 0; i < 2*sampleSize; i++) {
        for (int j = 0; j < 2*sampleSize; j++) {
            for (int k = 0; k < 2*sampleSize; k++) {
                vec3 current = start + vec3(i * dist, j * dist, k * dist);

                if (-sphMap(current, sphere) < 0) {
                    actualNr += 1;

                    phantomNeighbors[actualNr-1].x = current;
                    phantomNeighbors[actualNr-1].h = 0.05;
                    phantomNeighbors[actualNr-1].v = vec3(0);
                    phantomNeighbors[actualNr-1].m = 0.005236;

                    phantomNeighbors[actualNr-1].rho = 1;
                    phantomNeighbors[actualNr-1].p = 0;

                    phantomNeighbors[actualNr-1].staticP = 1;
                    phantomNeighbors[actualNr-1].padding = 0;
                }
            }
        }
    }
}

//----------------------------------------------------------------------------------------------------------------------

vec3 gradKernel(vec3 i, vec3 j) {
    float xijlength = length(i - j);
    if (xijlength == 0)
        return vec3(0);

    vec3 dir = (i - j) / xijlength;
    float val = 0;
    float q = xijlength/SimProps.kernelh;

    if (0 <= q && q < 1) {
        val = 3.0/2.0 * pow(q,2) - 2 * q;
        //val = 18 * pow(q, 2) - 12 * q;
    } else if (1 <= q && q < 2) {
        val = -pow(2 - q, 2)/2.0;
        //val = -6 * pow(1 - q, 2);
    } else {
        val = 0;
    }

    val *= 3.0/(2*PI) * 1.0/(pow(SimProps.kernelh, 3));
    //val *= 8.0 / (PI * pow(SimProps.kernelh, 3));
    dir *= val;

    return dir;
}

void copyData(uint gID) {
    storage_out.p[gID].x = storage_in.p[gID].x;
    storage_out.p[gID].h = storage_in.p[gID].h;
    storage_out.p[gID].v = storage_in.p[gID].v;
    storage_out.p[gID].m = storage_in.p[gID].m;

    storage_out.p[gID].rho = storage_in.p[gID].rho;
    storage_out.p[gID].p = storage_in.p[gID].p;

    storage_out.p[gID].staticP = storage_in.p[gID].staticP;
    storage_out.p[gID].padding = 1;
}

void iterate(uint i) {
    //getNeighbours(storage_in.p[i]);
    vec3 pressure = vec3(0);
    vec3 viscosity = vec3(0);

    for (int j = 0; j < SimProps.nr_of_particles; j++) {
        if (i == j)
            continue;

        // Note to self: as the particles get further and further from each other the density decreases which means rho --> 0
        // which leads to something/0^2, which is either inf or -inf ----> nan or -nan
        float val = 0;
        if (storage_in.p[j].rho != 0 && storage_in.p[i].rho != 0)
            val = storage_in.p[j].m * ((storage_in.p[i].p / pow(storage_in.p[i].rho, 2)) + (storage_in.p[j].p / pow(storage_in.p[j].rho, 2)));

        vec3 k = gradKernel(storage_in.p[i].x, storage_in.p[j].x);
        pressure += val * gradKernel(storage_in.p[i].x, storage_in.p[j].x);

        vec3 xij = storage_in.p[i].x - storage_in.p[j].x;

        float pval = 0;
        if (storage_in.p[j].rho != 0)
            pval = (storage_in.p[j].m / storage_in.p[j].rho) * (dot(xij, gradKernel(storage_in.p[i].x, storage_in.p[j].x)) /  (dot(xij, xij) + 0.01 * SimProps.kernelh));

        vec3 vij = storage_in.p[i].v - storage_in.p[j].v;
        viscosity += pval * vij;
    }

    // Phantom neighbours
    /*for (int j = 0; j < actualNr; j++) {
        float val = 0;
        if (phantomNeighbors[j].rho != 0 && storage_in.p[i].rho != 0)
            val = phantomNeighbors[j].m * ((storage_in.p[i].p / pow(storage_in.p[i].rho, 2)) + (phantomNeighbors[j].p / pow(phantomNeighbors[j].rho, 2)));

        vec3 k = gradKernel(storage_in.p[i].x, phantomNeighbors[j].x);
        pressure += val * gradKernel(storage_in.p[i].x, phantomNeighbors[j].x);

        vec3 xij = storage_in.p[i].x - phantomNeighbors[j].x;

        float pval = 0;
        if (phantomNeighbors[j].rho != 0)
            pval = (storage_in.p[j].m / phantomNeighbors[j].rho) * (dot(xij, gradKernel(storage_in.p[i].x, phantomNeighbors[j].x)) /  (dot(xij, xij) + 0.01 * SimProps.kernelh));

        vec3 vij = storage_in.p[i].v - storage_in.p[j].v;
        viscosity += pval * vij;
    }*/

    pressure *= -storage_in.p[i].m;

    float nu = 0.00001;
    viscosity *= 2 * nu * storage_in.p[i].m;
    //pressure *= 0.1;

    vec3 gravity = vec3(0, 0, -9.81) * storage_in.p[i].m;
    
    vec3 acc = (pressure + viscosity + gravity) / storage_in.p[i].m;

    float dt = 0.01;
    vec3 viNext = storage_in.p[i].v;
    vec3 xiNext = storage_in.p[i].x;
    viNext += acc * dt/2.0f;
    xiNext += viNext * dt;
    
    storage_out.p[i].x = xiNext;
    storage_out.p[i].v = viNext;
    storage_out.p[i].rho = storage_in.p[i].rho;
    storage_out.p[i].p = storage_in.p[i].p;
}

void main() {
    uint gID = gl_GlobalInvocationID.x;

    if (gID < SimProps.nr_of_particles) {
        copyData(gID);
        if (storage_in.p[gID].staticP == 0)
            iterate(gID);
    }
}