#version 450
layout (local_size_x = 256) in;//256

#include comp_shader.incl

#define storage_in out_data
#define storage_out in_data

struct Additional_data {
    vec3 dii;
    float aii;
    vec3 sumDijPj;
    float rho_adv;
    vec3 v_adv;
    float rho_pred;
};

layout(set = 0, binding = 4, std430) buffer additionalDataBuffer {
    Additional_data p[];
} add_data;

//----------------------------------------------------------------------------------------------------------------------

void copyData(uint gID) {
    storage_out.p[gID].x = storage_in.p[gID].x;
    storage_out.p[gID].h = storage_in.p[gID].h;
    storage_out.p[gID].v = storage_in.p[gID].v;
    storage_out.p[gID].m = storage_in.p[gID].m;

    storage_out.p[gID].rho = storage_in.p[gID].rho;
    storage_out.p[gID].p = storage_in.p[gID].p;

    storage_out.p[gID].staticP = storage_in.p[gID].staticP;
    storage_out.p[gID].padding = storage_in.p[gID].padding;
}

void computeVadvAndDii(uint gID) {
    vec3 f = vec3(0);
    vec3 dii = vec3(0);
    vec3 viscosity = vec3(0);

    for (int j = 0; j < ubo.nr_of_particles; j++) {
        if (gID == j)
            continue;

        // Viscosity calculation
        vec3 xij = storage_in.p[gID].x - storage_in.p[j].x;
        float pval = 0;
        if (storage_in.p[j].rho != 0)
            pval = (storage_in.p[j].m / storage_in.p[j].rho) * (dot(xij, cs_gradKernel(storage_in.p[gID].x, storage_in.p[j].x)) /  (dot(xij, xij) + 0.01 * ubo.kernelh));

        vec3 vij = storage_in.p[gID].v - storage_in.p[j].v;
        viscosity += pval * vij;
        
        // Dii calculation
        dii += -storage_in.p[j].m * cs_gradKernel(storage_in.p[gID].x, storage_in.p[j].x);
    }

    float nu = 0.01;
    viscosity *= 2 * nu * storage_in.p[gID].m;

    if (storage_in.p[gID].staticP == 0)
        f += viscosity;

    f += vec3(0, 0, -9.81 * storage_in.p[gID].m);

    float dt = 0.01;

    // Calculating v_adv
    add_data.p[gID].v_adv = storage_in.p[gID].v + dt * f / storage_in.p[gID].m;

    // Calculating dii
    if (abs(storage_in.p[gID].rho) > 0.0001)
        dii *= dt * dt / (storage_in.p[gID].rho * storage_in.p[gID].rho);
    else dii *= 0;

    add_data.p[gID].dii = dii;
}

void main()
{
    //grab global ID
    uint gID = gl_GlobalInvocationID.x;

    if (gID < ubo.nr_of_particles) {
        copyData(gID);
        computeVadvAndDii(gID);
    }
}