#version 450
layout (local_size_x = 64) in; //256

#include comp_shader.incl

#define storage_in out_data
#define storage_out in_data
#define SimProps ubo

//----------------------------------------------------------------------------------------------------------------------

void updateDensityAndPressure(uint gID) {
    float rho_change = 0;

    for (int j = 0; j < ubo.nr_of_particles; j++) {
        if (j == gID) continue;

        rho_change += storage_in.p[j].m * dot((ubo.dt * pcisph_add_data.p[gID].prev_p_acc - ubo.dt * pcisph_add_data.p[j].prev_p_acc), cs_gradKernel(storage_in.p[gID].x, storage_in.p[j].x));
    }

    rho_change *= ubo.dt;
    pcisph_add_data.p[gID].rho_pred += rho_change;

    pcisph_add_data.p[gID].padding1 = rho_change;
    pcisph_add_data.p[gID].padding2 = length(pcisph_add_data.p[gID].prev_p_acc - pcisph_add_data.p[3].prev_p_acc);

    float th = ubo.desired_density;
    if (pcisph_add_data.p[gID].rho_pred > ubo.desired_density)
        th = pcisph_add_data.p[gID].rho_pred;

    /*storage_in.p[gID].rho = pcisph_add_data.p[gID].rho_pred;
    storage_in.p[gID].p += ubo.kPCI * ((pcisph_add_data.p[gID].rho_pred - ubo.desired_density)/ubo.desired_density);
    storage_in.p[gID].p = storage_in.p[gID].p < -200 ? -200 : storage_in.p[gID].p;*/

    storage_in.p[gID].rho = th;
    storage_in.p[gID].p += ubo.kPCI * ((th - ubo.desired_density)/ubo.desired_density);
}

void main()
{
    //grab global ID
    uint gID = gl_GlobalInvocationID.x;

    if (gID < ubo.nr_of_particles) {
        updateDensityAndPressure(gID);
    }
}