#version 450
layout (local_size_x = 256) in;
precision highp float;

#define PI 3.1415926538

// Hashing constants
#define H1 73856093
#define H2 19349663
#define H3 83492791

#define list_size 12

struct Particle {
    vec3 x;                     // position
    float h;                    // radius
    vec3 v;                     // velocity
    float m;                    // mass

    float rho;                  // density
    float p;                    // pressure

    float staticP;               // is particle static
    float padding;
};

// SSBOs
//----------------------------------------------------------------------------------------------------------------------
layout(set = 0, binding = 0) uniform UBO {
    float desired_density;
    float k;                    // normalization constant / stiffness constant
    float nr_of_particles;
    float kernelh;

    vec4 gridA;
    vec4 gridB;
} ubo;

layout(set = 0, binding = 1, std430)  buffer inBuffer {
    Particle p[];
} in_data;

layout(set = 0, binding = 2, std430) buffer outBuffer {
    Particle p[];
} out_data;

//TODO a grid sosincs resetelve -> igy piszkos adat lehet benne
layout(set = 0, binding = 3, std430) buffer gridBuffer {
    int numbers[];
} grid_data;

// Spatial hash (or rather grid) related functions
//----------------------------------------------------------------------------------------------------------------------
int cellx = int(ceil(abs((ubo.gridB.x - ubo.gridA.x)/ubo.kernelh))); // Number of cells in x direction
int celly = int(ceil(abs((ubo.gridB.y - ubo.gridA.y)/ubo.kernelh))); // Number of cells in y direction
int cellz = int(ceil(abs((ubo.gridB.z - ubo.gridA.z)/ubo.kernelh))); // Number of cells in z direction

/*vec3 getCellNumbers() {
    int cellx = int(ceil((ubo.gridB.x - ubo.gridA.x)/ubo.kernelh)); // Number of cells in x direction
    int celly = int(ceil((ubo.gridB.y - ubo.gridA.y)/ubo.kernelh)); // Number of cells in y direction
    int cellz = int(ceil((ubo.gridB.z - ubo.gridA.z)/ubo.kernelh)); // Number of cells in z direction

    return vec3(x,y,z);
}*/

// Returns a vec3 (i,j,k) tuple which determines the cell in which the particle lies.
vec3 determineGridTuple(int particleIdx) {
    vec3 diff = ubo.gridA.xyz - in_data.p[particleIdx].x;
    diff /= ubo.kernelh;

    return floor(abs(diff));
}

int getStartIdxOfCell(vec3 tuple) {
    return int((tuple.x * cellz * celly + tuple.y * cellz + tuple.z)*list_size);
}

void placeParticleIntoCell(int particleIdx) {
    vec3 cellTuple = determineGridTuple(particleIdx);

    int startIdx = getStartIdxOfCell(cellTuple);
    uint realIdx = atomicAdd(grid_data.numbers[startIdx], 1);
    realIdx += startIdx + 1;

    // Placing particleIdx into cell
    grid_data.numbers[realIdx] = particleIdx;
    //grid_data.numbers[particleIdx] = int(realIdx);
}

// Main
//----------------------------------------------------------------------------------------------------------------------
void main()
{
    //grab global ID
    uint gID = gl_GlobalInvocationID.x;

    if (gID < ubo.nr_of_particles) {
        placeParticleIntoCell(int(gID));
        //grid_data.numbers[gID] = int(gID);
    }
    //grid_data.numbers[gID] = int(gID);

    //uint my_index = atomicAdd(out_data.numbers[0], 1);
    //out_data.numbers[my_index+1] = int(gID);
}