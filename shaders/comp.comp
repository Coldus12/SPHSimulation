#version 450
layout (local_size_x = 1024) in;
precision highp float;

#define PI 3.1415926538

struct Particle {
    vec3 x;                     // position
    float h;                    // radius
    vec3 v;                     // velocity
    float m;                    // mass

    float rho;                  // density
    float p;                    // pressure
};

layout(set = 0, binding = 0) uniform UBO {
    float desired_density;
    float k;                    // normalization constant / stiffness constant
    float nr_of_particles;
    float kernelh;
} ubo;

layout(set = 0, binding = 1, std430) readonly buffer inBuffer {
    Particle p[];
} in_data;

layout(set = 0, binding = 2, std430) buffer outBuffer {
    Particle p[];
} out_data;

// Kernel function from https://interactivecomputergraphics.github.io/SPH-Tutorial/pdf/SPH_Tutorial.pdf
// http://web.cse.ohio-state.edu/~wang.3602/courses/cse3541-2017-fall/08-SPH.pdf
// https://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf <--- Current version.
float kernel(Particle i, Particle j, float h) {
    float q = length(i.x - j.x)/h;
    float oneoverhd = 1/(pow(h, 3));
    float val = 0;

    if (0 <= q && q < 1) {
        val = 2/3 - pow(q, 2) + pow(q,3)/2;
    } else if (1 <= q && q < 2) {
        val = pow(2-q, 3)/6;
    } else {
        val = 0;
    }

    val *= 3/(2*PI);
    val *= oneoverhd;
    return val;
}

float calculate_density(uint id) {
    float density = 0.0;
    Particle pi = in_data.p[id];

    for (int j = 0; j < ubo.nr_of_particles; j++) {
        if (j != id) {
            Particle pj = in_data.p[j];
            density += pj.m * kernel(pi, pj, ubo.kernelh);
        }
    }

    return density;
}

float calculate_pressure(uint id, float rho) {
    float ratio = rho/ubo.desired_density;
    float p = ubo.k * (pow(ratio, 7.0) - 1.0);

    return p;
}

void main()
{
    //grab global ID
    uint gID = gl_GlobalInvocationID.x;

    float rho = calculate_density(gID);
    float p = calculate_pressure(gID, rho);

    out_data.p[gID].x = in_data.p[gID].x;
    out_data.p[gID].h = in_data.p[gID].h;
    out_data.p[gID].v = in_data.p[gID].v;
    out_data.p[gID].m = in_data.p[gID].m;

    out_data.p[gID].rho = rho;
    out_data.p[gID].p = p;

    //out_data.p[gID].rho = in_data.p[gID].rho;
    //out_data.p[gID].p = in_data.p[gID].p;
}