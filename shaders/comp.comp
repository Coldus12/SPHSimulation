#version 450
layout (local_size_x = 1) in;
precision highp float;

#define PI 3.1415926538

struct Particle {
    vec3 x;                     // position
    float h;                    // radius
    vec3 v;                     // velocity
    float m;                    // mass

    float rho;                  // density
    float p;                    // pressure

    float staticP;               // is particle static
    float padding;
};

layout(set = 0, binding = 0) uniform UBO {
    float desired_density;
    float k;                    // normalization constant / stiffness constant
    float nr_of_particles;
    float kernelh;
} ubo;

layout(set = 0, binding = 1, std430)  buffer inBuffer {
    Particle p[];
} in_data;

layout(set = 0, binding = 2, std430) buffer outBuffer {
    Particle p[];
} out_data;

float kernel(uint i, uint j) {
    float q = length(in_data.p[i].x - in_data.p[j].x) / ubo.kernelh;
    float oneoverhd = 1.0/(pow(ubo.kernelh, 3));
    float val = 0;

    if (0 <= q && q < 1) {
        val = 2.0/3.0 - pow(q, 2) + pow(q,3)/2;
        //val = 6 * (pow(q, 3) - pow(q, 2)) + 1;
    } else if (1 <= q && q < 2) {
        val = pow(2-q, 3)/6.0;
        //val = 2 * pow(1 - q, 3);
    } else {
        val = 0;
    }

    val *= 3.0/(2.0*PI);
    //val *= 8.0 / (PI * pow(ubo.kernelh, 3));
    val *= oneoverhd;

    if (val < 0.001)
        val = 0;

    return val;
}

void copyData(uint gID) {
    out_data.p[gID].x = in_data.p[gID].x;
    out_data.p[gID].h = in_data.p[gID].h;
    out_data.p[gID].v = in_data.p[gID].v;
    out_data.p[gID].m = in_data.p[gID].m;

    out_data.p[gID].rho = in_data.p[gID].rho;
    out_data.p[gID].p = in_data.p[gID].p;

    out_data.p[gID].staticP = in_data.p[gID].staticP;
    out_data.p[gID].padding = 1;
}

void calculateRhoAndP(uint gID) {
    float density = 0.0;

    for (int j = 0; j < ubo.nr_of_particles; j++) {
        if (gID == j)
            continue;

        density += in_data.p[gID].m * kernel(gID, j);
    }

    out_data.p[gID].rho = density;

    float ratio = density / ubo.desired_density;
    out_data.p[gID].p = ubo.k * (pow(ratio, 7) - 1.0);
    //out_data.p[gID].p = 0.001 * (pow(ratio, 7) - 1.0);
}

void main()
{
    //grab global ID
    uint gID = gl_GlobalInvocationID.x;

    if (gID < ubo.nr_of_particles) {
        copyData(gID);
        calculateRhoAndP(gID);
    }
}